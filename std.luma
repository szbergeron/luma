mod primitive {

    struct Unit {}

    struct Parameterized<T> {
        var v: T,
    }

    struct i64 {
        /*fn dyn_fields() -> std::primitive::i64 {
            42.dynf
        },*/

        /*fn err_dyn_fields_1() -> std::primitive::Unit {
            let b = 42.dynf;
            struct Unit {};

            let c = b * 3;

            c
        },*/

        fn operator[_*_](self: std::primitive::i64, other: std::primitive::i64) -> std::primitive::i64 {
            self * other
        },
    }

    /*fn construction() -> std::primitive::Parameterized<std::primitive::i64> {
        struct std::primitive::Parameterized { v: 42.dynf }
    }

    fn construction2() -> std::primitive::Parameterized<std::primitive::i64> {
        struct std::primitive::Parameterized { v: 42.dynf }
    }

    fn err_dyn_fields_2() -> std::primitive::Unit {
        42.dynf
    }*/

    /*fn assignment() -> std::primitive::Unit {
        let b = 5;

        b = struct std::primitive::Unit {};
    }*/

    fn funky_dyn_fields(a: std::primitive::i64) -> std::primitive::i64 {
        //a.def = a.def;
        a.abc = 5;
        a.abc = 5 * a.abc;


        a.def = struct std::primitive::Unit {};

        a.def = a.abc;

        a.g = a.g;

        a.abc
    },
}

/*

    struct i64 {
        fn operator[_+_](self: std::primitive::i64, other: std::primitive::i64) -> std::primitive::i64 {
            self + other
        },

        fn operator[_/_](self: std::primitive::i64, other: std::primitive::i64) -> std::primitive::i64 {
            self / other
        },

        fn operator[_-_](self: std::primitive::i64, other: std::primitive::i64) -> std::primitive::i64 {
            self - other
        },
    }

    struct i32 {
        fn operator[_*_](self: std::primitive::i32, other: std::primitive::i32) -> std::primitive::i32 {
            //5 + 3 / 2
            //3 / 2
            //3 + 3 / 2 - 5
            //3.operator[_+_]()
            self * other
        },

        fn incorrect_second_operand_type(a: std::primitive::i32, b: std::primitive::i64) -> std::primitive::i32 {
            a * b
            //3 / a;
        },

        fn foo(a: std::primitive::i32, b: std::primitive::i32) -> std::primitive::i32 {
            a.foo(b)
        }

        fn incorrect_return_type(a: std::primitive::i32, b: std::primitive::i32) -> std::primitive::i64 {
            a.foo(b)
        }

    }

    struct Wrap<T> {
        //var f: T,
    }

    fn w() -> std::primitive::Wrap<std::primitive::i32> {
        struct std::primitive::Wrap { }
    }


mod pointers {
    struct reference<T> {
        var v: T,
    }
}
*/
