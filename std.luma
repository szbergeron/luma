mod primitive {

    struct Unit {}

    struct i64 {
        fn operator[_*_](self: std::primitive::i64, other: std::primitive::i64) -> std::primitive::i64 {
            self * other
        };

    };

    struct bool {
        fn operator[_==_](self: std::primitive::bool, other: std::primitive::bool) -> std::primitive::bool #builtin luma__fast_bool_compare_eq luma__silly_bool_compare_eq luma__slow_bool_compare_eq;
    };

    struct huh {
        var a: std::primitive::i64;
        var b: std::primitive::i64;

        fn woo(self: std::primitive::huh) -> std::primitive::huh {
            self
        }
    };

    fn compose() -> std::primitive::huh {
        let h = struct std::primitive::huh { a: 5, b: 6 };

        h.woo(h);

        h
    };

    struct parametric<T> {
        var val: T;

        fn change<T>(self: parametric<T>, val: T) -> std::primitive::Unit {
            self.val = val;

            struct std::primitive::Unit {}
        }
    }

    fn p() -> std::primitive::Unit {
        let pa = struct std::primitive::parametric { val: 4 };
        pa.change(pa, 5);

        struct std::primitive::Unit {}
    }

    fn funky_dyn_fields(a: std::primitive::i64) -> std::primitive::i64 {
        //a.def = a.def;
        a.abc = 5;
        a.abc = 5 * a.abc;


        //a.def = struct std::primitive::Unit {};

        a.def = a.abc;

        //a.g = a.g;

        a.abc
    }

}

/*

    struct i64 {
        fn operator[_+_](self: std::primitive::i64, other: std::primitive::i64) -> std::primitive::i64 {
            self + other
        };

        fn operator[_/_](self: std::primitive::i64, other: std::primitive::i64) -> std::primitive::i64 {
            self / other
        };

        fn operator[_-_](self: std::primitive::i64, other: std::primitive::i64) -> std::primitive::i64 {
            self - other
        };
    }

    struct i32 {
        fn operator[_*_](self: std::primitive::i32, other: std::primitive::i32) -> std::primitive::i32 {
            //5 + 3 / 2
            //3 / 2
            //3 + 3 / 2 - 5
            //3.operator[_+_]()
            self * other
        };

        fn incorrect_second_operand_type(a: std::primitive::i32, b: std::primitive::i64) -> std::primitive::i32 {
            a * b
            //3 / a;
        };

        fn foo(a: std::primitive::i32, b: std::primitive::i32) -> std::primitive::i32 {
            a.foo(b)
        };

        fn incorrect_return_type(a: std::primitive::i32, b: std::primitive::i32) -> std::primitive::i64 {
            a.foo(b)
        };

    }

    struct Wrap<T> {
        //var f: T;
    }

    fn w() -> std::primitive::Wrap<std::primitive::i32> {
        struct std::primitive::Wrap { }
    }

    struct Vec<T> {
        fn push<U>(self: std::primitive::Vec<U>, v: U) -> std::primitive::i64 {
            5
        };

        fn pop<U>(self: std::primitive::Vec<U>) -> U {
            5
        };
    }

    fn vecs(v: Vec<i64>) -> std::primitive::Unit {
        let v = struct std::primitive::Vec {};

        v.pop(v)
    }

    fn gen1<T>(v: T) -> T {
        v
    };

    fn gen2() -> std::primitive::Unit {
        std::primitive::gen1(struct std::primitive::Unit {})
        //gen1(5)
    }
        /*fn dyn_fields() -> std::primitive::i64 {
            42.dynf
        };*/

        /*fn err_dyn_fields_1() -> std::primitive::Unit {
            let b = 42.dynf;
            struct Unit {};

            let c = b * 3;

            c
        };*/

//    fn construction() -> std::primitive::Parameterized<std::primitive::i64> {
//        struct std::primitive::Parameterized { v: 42.dynf }
//    }

//    fn construction2() -> std::primitive::Parameterized<std::primitive::i64> {
//        struct std::primitive::Parameterized { v: 42.dynf }
//    }

    /*fn err_dyn_fields_2() -> std::primitive::Unit {
        42.dynf
    }*/

    /*fn assignment() -> std::primitive::Unit {
        let b = 5;

        b = struct std::primitive::Unit {};
    }*/



mod pointers {
    struct reference<T> {
        var v: T;
    }
}
*/
