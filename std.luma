mod primitive {

    fn print<T>(v: T) -> std::primitive::Unit #builtin luma_print_fast luma_print_silly luma_print_slow;

    struct Unit {}

    struct i64 noref {
        fn operator[_*_](self: std::primitive::i64, other: std::primitive::i64) -> std::primitive::i64 {
            self * other
        };

        fn operator[_+_](self: std::primitive::i64, other: std::primitive::i64) -> std::primitive::i64
            #builtin luma_i64_op_add_fast luma_i64_op_add_silly luma_i64_op_add_slow;

        fn operator[_-_](self: std::primitive::i64, other: std::primitive::i64) -> std::primitive::i64
            #builtin luma_i64_op_subtract_fast luma_i64_op_subtract_silly luma_i64_op_subtract_slow;

        fn operator[_==_](self: std::primitive::i64, other: std::primitive::i64) -> std::primitive::bool
            #builtin luma_i64_op_eq_fast luma_i64_op_eq_silly luma_op_eq_slow;

    };

    struct bool noref {
        fn operator[_==_](self: std::primitive::bool, other: std::primitive::bool) -> std::primitive::bool
            #builtin luma__fast_bool_compare_eq luma__silly_bool_compare_eq luma_op_eq_slow;
    };

    struct huh {
        var a: std::primitive::i64;
        var b: std::primitive::i64;

        fn woo(self: std::primitive::huh) -> std::primitive::huh {
            self
        };

        fn add_dynf(self: std::primitive::huh) -> std::primitive::huh {
            self.d = 10;

            self
        };
    };

    fn compose() -> std::primitive::huh {
        let h = struct std::primitive::huh { a: 5, b: 6 };

        h.woo(h);

        h
    };

    /*struct parametric<T> {
        var val: T;

        fn change<T>(self: parametric<T>, val: T) -> std::primitive::Unit {
            self.val = val;

            struct std::primitive::Unit {}
        }
    }

    fn p() -> std::primitive::Unit {
        let pa = struct std::primitive::parametric { val: 4 };
        pa.change(pa, 5);

        pa.change(pa, pa.val + 3);

        //std::primitive::print(pa.val);

        struct std::primitive::Unit {}
    }*/

    struct fdf isref ismod {
    };

    fn funky_dyn_fields(a: std::primitive::fdf) -> std::primitive::i64 {
        //a.def = a.def;
        a.abc = 5;
        a.abc = 5 * a.abc;


        //a.def = struct std::primitive::Unit {};

        a.def = a.abc;

        //a.g = a.g;

        a.abc
    }

    fn fibonacci(n: std::primitive::i64) -> std::primitive::i64 {
        if n == 0 {
            0
        } else if n == 1 {
            1
        } else {
            std::primitive::fibonacci(n - 1) + std::primitive::fibonacci(n - 2)
        }
    }

    fn fib_test() -> std::primitive::Unit {
        std::primitive::fibonacci(20);

        struct std::primitive::Unit {}
    }

}

/*

    struct i64 {
        fn operator[_+_](self: std::primitive::i64, other: std::primitive::i64) -> std::primitive::i64 {
            self + other
        };

        fn operator[_/_](self: std::primitive::i64, other: std::primitive::i64) -> std::primitive::i64 {
            self / other
        };

        fn operator[_-_](self: std::primitive::i64, other: std::primitive::i64) -> std::primitive::i64 {
            self - other
        };
    }

    struct i32 {
        fn operator[_*_](self: std::primitive::i32, other: std::primitive::i32) -> std::primitive::i32 {
            //5 + 3 / 2
            //3 / 2
            //3 + 3 / 2 - 5
            //3.operator[_+_]()
            self * other
        };

        fn incorrect_second_operand_type(a: std::primitive::i32, b: std::primitive::i64) -> std::primitive::i32 {
            a * b
            //3 / a;
        };

        fn foo(a: std::primitive::i32, b: std::primitive::i32) -> std::primitive::i32 {
            a.foo(b)
        };

        fn incorrect_return_type(a: std::primitive::i32, b: std::primitive::i32) -> std::primitive::i64 {
            a.foo(b)
        };

    }

    struct Wrap<T> {
        //var f: T;
    }

    fn w() -> std::primitive::Wrap<std::primitive::i32> {
        struct std::primitive::Wrap { }
    }

    struct Vec<T> {
        fn push<U>(self: std::primitive::Vec<U>, v: U) -> std::primitive::i64 {
            5
        };

        fn pop<U>(self: std::primitive::Vec<U>) -> U {
            5
        };
    }

    fn vecs(v: Vec<i64>) -> std::primitive::Unit {
        let v = struct std::primitive::Vec {};

        v.pop(v)
    }

    fn gen1<T>(v: T) -> T {
        v
    };

    fn gen2() -> std::primitive::Unit {
        std::primitive::gen1(struct std::primitive::Unit {})
        //gen1(5)
    }
        /*fn dyn_fields() -> std::primitive::i64 {
            42.dynf
        };*/

        /*fn err_dyn_fields_1() -> std::primitive::Unit {
            let b = 42.dynf;
            struct Unit {};

            let c = b * 3;

            c
        };*/

//    fn construction() -> std::primitive::Parameterized<std::primitive::i64> {
//        struct std::primitive::Parameterized { v: 42.dynf }
//    }

//    fn construction2() -> std::primitive::Parameterized<std::primitive::i64> {
//        struct std::primitive::Parameterized { v: 42.dynf }
//    }

    /*fn err_dyn_fields_2() -> std::primitive::Unit {
        42.dynf
    }*/

    /*fn assignment() -> std::primitive::Unit {
        let b = 5;

        b = struct std::primitive::Unit {};
    }*/



mod pointers {
    struct reference<T> {
        var v: T;
    }
}
*/
