struct i64 noref #builtin "i64" {
    fn operator[_*_](self: std::i64, other: std::i64) -> std::i64 
        #builtin "luma_i64_op_mul_fast($self, $other)" "luma_i64_op_mul_silly($self, $other)" "luma_op_mul_slow($self, $other)";

    fn operator[_+_](self: std::i64, other: std::i64) -> std::i64
        #builtin "luma_i64_op_add_fast($self, $other)" "luma_i64_op_add_silly($self, $other)" "luma_op_add_slow($self, $other)";

    fn operator[_-_](self: std::i64, other: std::i64) -> std::i64
        #builtin "luma_i64_op_subtract_fast($self, $other)" "luma_i64_op_subtract_silly($self, $other)" "luma_op_subtract_slow($self, $other)";

    fn operator[_==_](self: std::i64, other: std::i64) -> std::bool
        #builtin "luma_i64_op_eq_fast($self, $other)" "luma_i64_op_eq_silly($self, $other)" "luma_op_eq_slow($self, $other)";

    fn operator[_!=_](self: std::i64, other: std::i64) -> std::bool
        #builtin "luma_i64_op_eq_fast($self, $other)" "luma_i64_op_eq_silly($self, $other)" "luma_op_eq_slow($self, $other)";

    fn operator[_<_](self: std::i64, other: std::i64) -> std::bool
        #builtin "luma_i64_op_lt_fast($self, $other)" "luma_i64_op_lt_silly($self, $other)" "luma_op_lt_slow($self, $other)";

    fn operator[_>_](self: std::i64, other: std::i64) -> std::bool
        #builtin "$self > $other" "luma_i64_op_gt_silly($self, $other)" "luma_op_gt_slow($self, $other)";

    fn to_string(self: std::i64) -> std::String
        #builtin "$self.to_string()" "" "luma_to_string_slow($self)";
};

struct f64 noref #builtin "f64" {
    fn operator[_*_](self: std::f64, other: std::f64) -> std::f64 
        #builtin "$self * $other" "luma_i64_op_mul_silly($self, $other)" "luma_op_mul_slow($self, $other)";

    fn operator[_+_](self: std::f64, other: std::f64) -> std::f64
        #builtin "$self + $other" "luma_i64_op_add_silly($self, $other)" "luma_op_add_slow($self, $other)";

    fn operator[_-_](self: std::f64, other: std::f64) -> std::f64
        #builtin "$self - $other" "luma_i64_op_subtract_silly($self, $other)" "luma_op_subtract_slow($self, $other)";

    fn operator[_/_](self: std::f64, other: std::f64) -> std::f64
        #builtin "$self / $other" "luma_i64_op_subtract_silly($self, $other)" "luma_op_subtract_slow($self, $other)";

    fn operator[_==_](self: std::f64, other: std::f64) -> std::bool
        #builtin "$self == $other" "luma_i64_op_eq_silly($self, $other)" "luma_op_eq_slow($self, $other)";

    fn operator[_!=_](self: std::f64, other: std::f64) -> std::bool
        #builtin "$self != $other" "luma_i64_op_eq_silly($self, $other)" "luma_op_eq_slow($self, $other)";

    fn operator[_<_](self: std::f64, other: std::f64) -> std::bool
        #builtin "$self < $other" "luma_i64_op_lt_silly($self, $other)" "luma_op_lt_slow($self, $other)";

    fn operator[_>_](self: std::f64, other: std::f64) -> std::bool
        #builtin "$self > $other" "luma_i64_op_gt_silly($self, $other)" "luma_op_gt_slow($self, $other)";

    fn to_string(self: std::f64) -> std::String
        #builtin "$self.to_string()" "" "luma_to_string_slow($self)";

    fn pow(self: std::f64, p: std::f64) -> std::f64
        #builtin "$self.powf($p)" "" "luma_op_pow_slow($self, $p)";

    fn sqrt(self: std::f64) -> std::f64
        #builtin "$self.sqrt()" "" "luma_op_sqrt_slow($self)";

    fn abs(self: std::f64) -> std::f64 #builtin "$self.abs()" "" "luma_op_abs_slow($self)";

    fn modulo(self: std::f64, modby: std::f64) -> std::f64 #builtin "$self % $modby" "" "luma_op_modulo_slow($self, $modby)";

    fn rand() -> std::f64 #builtin "rand_f64()" "" "luma_f64_rand_slow()";

    fn cos(self: std::f64) -> std::f64 {
        std::cosine(self)
    };
}

struct bool noref #builtin "bool" {
    fn operator[_==_](self: std::bool, other: std::bool) -> std::bool
        #builtin
            "$self == $other"
            "luma__silly_bool_compare_eq"
            "luma_op_eq_slow($self, $other)";
};

fn cosine(v: std::f64) -> std::f64 #builtin "$v.cos()" "" "luma_op_cos_slow($v)";

fn print<T>(v: T) -> std::Unit #builtin "luma_print_fast($v);" "luma_print_silly" "luma_print_slow($v)";

struct Unit noref #builtin "()" {}

struct String noref #builtin "String" {
    fn operator[_+_](self: std::String, other: std::String) -> std::String
        #builtin
        "{ let mut first = $self; first.push_str($other.as_str()); first }" "" "luma_op_add_slow($self, $other)";

    /*
    fn operator[_+_](self: std::String, other: std::i64) -> std::String {
        self + other.to_string(other)
    };
    */
}

//struct LumaVec<T> #builtin 

struct Vec<T> noref #builtin "FastRefHandle<Vec<$T>>" {
    fn push<T>(self: std::Vec<T>, item: T) #builtin "$self.borrow_mut().push($item);" "" "luma_vec_push_slow($self, $item)";

    fn get<T>(self: std::Vec<T>, ind: std::i64) -> T #builtin "$self.borrow_mut().get($ind as usize).cloned().unwrap()" "" "luma_vec_get_slow($self, $ind)";

    fn new<T>() -> std::Vec<T> #builtin "FastRefHandle::from_val(Vec::new())" "" "luma_vec_new_slow()";

    fn with_capacity<T>(capacity: std::i64) -> std::Vec<T> #builtin "FastRefHandle::from_val(Vec::with_capacity($capacity as usize))" "" "luma_vec_new_slow()";

    fn len<T>(self: std::Vec<T>) -> std::i64 #builtin "$self.borrow_mut().len() as i64" "" "luma_vec_len_slow($self)";
    //fn new_i64() -> std::Vec<i64> #builtin "Vec::new" "" "";
}

/*
// don't use, this is broken for some reason
struct ValueVec<T> noref #builtin "Vec<$T>" {
    fn push<T>(self: std::ValueVec<T>, item: T) #builtin "$self.push($item);" "" "luma_vec_push_slow($self, $item)";

    fn get<T>(self: std::ValueVec<T>, ind: std::i64) -> T #builtin "$self.get($ind as usize).cloned().unwrap()" "" "luma_vec_get_slow($self, $ind)";

    fn new<T>() -> std::ValueVec<T> #builtin "Vec::new()" "" "luma_vec_new_slow()";

    fn with_capacity<T>(capacity: std::i64) -> std::ValueVec<T> #builtin "Vec::with_capacity($capacity)" "" "luma_vec_new_slow()";

    fn len<T>(self: std::ValueVec<T>) -> std::i64 #builtin "$self.len() as i64" "" "";
}
*/


//struct VecInner noref #builtin Vec<T> {}

/*fn v(vi: VecInner) {
}*/

fn funky_dyn_fields(a: std::fdf) -> std::i64 {
    //a.def = a.def;
    a.abc = 5;
    a.abc = 5 * a.abc;


    //a.def = struct std::Unit {};

    a.def = a.abc;

    //let v = a.abc;
    //a.def = v;

    a.g = struct std::fdf { b: 20 };

    a.h = "h";

    //a.g = a.g;

    a.abc
}

struct fdf isref ismod {
    var b: std::i64;
};


fn tmain() {

    std::print("hello world");

    std::print("this is 2 + 2:");
    if true {
        std::print(2 + 2);
    }

    std::vectest3();
    std::assigntest();
    std::takes_vecs_test();
    //std::print("hello" + " " + 42.to_string());

    //let bob = std::test_dyn_fields();

    //std::check_dyn_usage(bob);
};
/*
fn vectest() -> Vec<i64> {
    Vec::new()
}
*/

fn vectest3() {
    let v = Vec::new();
    v.push(5);

    std::print(v.get(0))

    //v.push(v, "hello");
}

fn takes_vecs(a: std::Vec<i64>, b: std::Vec<i64>) {
    std::print(a.get(0) + b.get(1));
}

fn takes_vecs_test() {
    let v = std::Vec::new();
    v.push(10);
    v.push(11);

    std::takes_vecs(v, v);
}

struct A {
    var v: std::i64;
}

fn assigntest() {
    let a = 10;
    let b = 20;
    let c = a;

    let d = struct std::A { v: a };

    d.v = b;

    b = d.v;

    //if c == 0 { a } else { b } = 30;

    //
}

struct User {
    var name: std::String;
    var age: std::i64;
}

fn test_dyn_fields() -> std::User {
    let bob = struct std::User { name: "Bob", age: 20 };

    std::print("bob's age is");
    std::print(bob.age);

    bob.married = true;

    std::print("bob marital status:");
    std::print(bob.married);

    bob.married = false;

    //bob.married = "yes";

    bob
}

struct A_Struct {
}

fn check_dyn_usage(u: User) {
    let v = struct std::A_Struct {};

    u.adsfjkl = "hi";

    //v.b = u.married;
    v.b = u.adsfjkl;

    //std::print("v.b is:");
    //std::print(v.b);
}

fn bad_dyn_usage(u: std::User) {
    //u.married = "no"
}

fn fibonacci(n: std::i64) -> std::i64 {
    if n == 0 {
        0
    } else if n == 1 {
        1
    } else {
        std::fibonacci(n - 1) + std::fibonacci(n - 2)
    }
};

fn fib_test() -> std::i64 {
    std::fibonacci(17)

    //struct std::Unit {}
};

fn ackermann(m: std::i64, n: std::i64) -> std::i64 {
    if m == 0 {
        n + 1
    } else if n == 0 {
        std::ackermann(m - 1, 1)
    } else {
        std::ackermann(m - 1, std::ackermann(m, n - 1))
    }
};

/*
struct VecOfInt {
    var v: std::Vec<std::i64>;

    fn new() -> std::VecOfInt #builtin "" "" "";
}

fn vectest2() {
    let v = std::VecOfInt::new();

    v.v.push(v.v, 10);
}
*/

/*



struct parametric<T> {
    var val: T;

    fn change<T>(self: parametric<T>, val: T) -> std::Unit {
        self.val = val;

    }
}

fn p() -> std::Unit {
    let pa = struct std::parametric { val: 4 };
    pa.change(pa, 5);

    pa.change(pa, pa.val + 3);


    std::print(pa.val);


    //std::print(pa.val);

    //struct std::Unit {}
}

fn hw() -> std::Unit {
    std::print("hello world");
};






struct fdf isref ismod {
    var b: std::i64;
};

struct sref isref ismod {
    var v: std::sref;
};

fn sref_s(s: std::sref) -> std::Unit {
};

fn funky_dyn_fields(a: std::fdf) -> std::i64 {
    //a.def = a.def;
    a.abc = 5;
    a.abc = 5 * a.abc;


    //a.def = struct std::Unit {};

    a.def = a.abc;

    a.g = struct std::fdf { b: 20 };

    //a.g = a.g;

    a.abc
}

fn fibonacci(n: std::i64) -> std::i64 {
    if n == 0 {
        0
    } else if n == 1 {
        1
    } else {
        std::fibonacci(n - 1) + std::fibonacci(n - 2)
    }
};

fn fib_test() -> std::i64 {
    std::fibonacci(17)

    //struct std::Unit {}
};

fn ackermann(m: std::i64, n: std::i64) -> std::i64 {
    if m == 0 {
        n + 1
    } else if n == 0 {
        std::ackermann(m - 1, 1)
    } else {
        std::ackermann(m - 1, std::ackermann(m, n - 1))
    }
};

fn ackermann_test() -> std::i64 {
    std::ackermann(3, 4)
};

struct huh {
    var a: std::i64;
    var b: std::i64;

    fn woo(self: std::huh) -> std::huh {
        self
    };

    fn add_dynf(self: std::huh) -> std::huh {
        self.d = 10;

        self
    };
};

fn for_loop(from: std::i64, until: std::i64) -> std::Unit {
    let b = 0;
    for(let a = from; a < until; a = a + 1) {
        b = b + 1;
    }
};

/*
fn bad_scope() -> std::Unit {
    if 1 == 2 {
        let a = 3;
        4
    } else {
        a
    }
}
*/

fn compose() -> std::huh {
    let h = struct std::huh { a: 5, b: 6 };

    h.woo(h);

    h.a = 10;

    //std::print(h.a);

    h
};

fn just_simple() -> std::i64 {
    42
}
*/


/*

struct i64 {
    fn operator[_+_](self: std::i64, other: std::i64) -> std::i64 {
        self + other
    };

    fn operator[_/_](self: std::i64, other: std::i64) -> std::i64 {
        self / other
    };

    fn operator[_-_](self: std::i64, other: std::i64) -> std::i64 {
        self - other
    };
}

struct i32 {
    fn operator[_*_](self: std::i32, other: std::i32) -> std::i32 {
        //5 + 3 / 2
        //3 / 2
        //3 + 3 / 2 - 5
        //3.operator[_+_]()
        self * other
    };

    fn incorrect_second_operand_type(a: std::i32, b: std::i64) -> std::i32 {
        a * b
        //3 / a;
    };

    fn foo(a: std::i32, b: std::i32) -> std::i32 {
        a.foo(b)
    };

    fn incorrect_return_type(a: std::i32, b: std::i32) -> std::i64 {
        a.foo(b)
    };

}

struct Wrap<T> {
    //var f: T;
}

fn w() -> std::Wrap<std::i32> {
    struct std::Wrap { }
}

struct Vec<T> {
    fn push<U>(self: std::Vec<U>, v: U) -> std::i64 {
        5
    };

    fn pop<U>(self: std::Vec<U>) -> U {
        5
    };
}

fn vecs(v: Vec<i64>) -> std::Unit {
    let v = struct std::Vec {};

    v.pop(v)
}

fn gen1<T>(v: T) -> T {
    v
};

fn gen2() -> std::Unit {
    std::gen1(struct std::Unit {})
    //gen1(5)
}
    /*fn dyn_fields() -> std::i64 {
        42.dynf
    };*/

    /*fn err_dyn_fields_1() -> std::Unit {
        let b = 42.dynf;
        struct Unit {};

        let c = b * 3;

        c
    };*/

//    fn construction() -> std::Parameterized<std::i64> {
//        struct std::Parameterized { v: 42.dynf }
//    }

//    fn construction2() -> std::Parameterized<std::i64> {
//        struct std::Parameterized { v: 42.dynf }
//    }

/*fn err_dyn_fields_2() -> std::Unit {
    42.dynf
}*/

/*fn assignment() -> std::Unit {
    let b = 5;

    b = struct std::Unit {};
}*/



mod pointers {
struct reference<T> {
    var v: T;
}
}
*/
